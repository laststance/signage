---
description: 
globs: 
alwaysApply: false
---
# KleoSr Autonomous Workflow System

## Overview
This rule establishes an autonomous AI workflow system based on the KleoSr methodology. The AI operates through a continuous loop using two core configuration files that manage both stable project settings and dynamic workflow state.

## Core Configuration Files

### Project Constitution
The stable, long-term project configuration is defined in [project_config.md](mdc:cursorkleosr/project_config.md). This file contains:
- Project goals and requirements
- Tech stack specifications
- Coding patterns and conventions
- Performance requirements
- Key limitations and considerations

### Dynamic Workflow Brain
The dynamic workflow state and rules are managed in [workflow_state.md](mdc:cursorkleosr/workflow_state.md). This file contains:
- Current workflow phase and status
- Active plan and next steps
- Embedded workflow rules
- Tool usage guidelines
- Real-time log of actions and decisions

## Autonomous Loop Protocol

### 1. READ Phase
- Always begin by reading [workflow_state.md](mdc:cursorkleosr/workflow_state.md) to understand current situation
- Review the Current State section for phase, status, and active tasks
- Check the Plan section for next steps
- Examine the Log for recent context

### 2. INTERPRET Phase
- Determine which workflow rule applies based on current phase
- Identify required actions according to the embedded rules
- Consider project patterns from [project_config.md](mdc:cursorkleosr/project_config.md)

### 3. ACT Phase
- Execute the determined action using appropriate Cursor tools
- Follow phase-specific rules from the workflow state
- Maintain adherence to project conventions and tech stack

### 4. UPDATE Phase
- Immediately record the action and result in [workflow_state.md](mdc:cursorkleosr/workflow_state.md)
- Update the Current State section with new phase/status
- Add log entry with timestamp and brief description
- Update the Plan section if progress was made

### 5. REPEAT
- Continue the loop until task completion or user intervention
- Maintain context through the workflow state file
- Handle errors according to embedded recovery rules

## Workflow Phases

### ANALYZE
- Understand task requirements and project context
- Review existing codebase and identify modification points
- Status: ANALYZING

### BLUEPRINT
- Create detailed implementation plan with specific steps
- Reference exact files and functions to modify
- Status: NEEDS_PLAN_APPROVAL (wait for user confirmation)

### CONSTRUCT
- Implement according to approved plan
- Generate complete, functional code without placeholders
- Status: IMPLEMENTING

### VALIDATE
- Test implementation with linting, formatting, and runtime checks
- Status: VALIDATING

## Critical Rules

### Code Quality
- Generate only complete, functional code (no TODO comments or placeholders)
- Follow TypeScript strict mode and ESLint configuration
- Use project-specific patterns from [project_config.md](mdc:cursorkleosr/project_config.md)

### Autonomy Guidelines
- Always read workflow state before taking any action
- Update workflow state after every significant action
- Wait for explicit user approval before proceeding from BLUEPRINT to CONSTRUCT
- Handle common errors (linting, formatting) automatically according to embedded rules

### Performance Considerations
- Optimize for continuous display operation (signage context)
- Target 60fps for animations
- Implement proper memory management for long-running sessions

## Integration Notes
- This system works with OpenRouter models and MCP servers
- Terminal commands are used for linting, formatting, and testing
- File operations maintain proper context through workflow state
- Error recovery follows embedded rules in workflow state file
